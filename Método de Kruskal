import java.util.*;

class Edge implements Comparable<Edge> {
    int src, dest, weight;

    Edge(int src, int dest, int weight) {
        this.src = src;
        this.dest = dest;
        this.weight = weight;
    }

    public int compareTo(Edge other) {
        return this.weight - other.weight;
    }

    @Override
    public String toString() {
        return src + " – " + dest + " (peso: " + weight + ")";
    }
}

class UnionFind {
    int[] parent, rank;

    UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    int find(int u) {
        if (parent[u] != u)
            parent[u] = find(parent[u]);
        return parent[u];
    }

    boolean union(int u, int v) {
        int rootU = find(u);
        int rootV = find(v);
        if (rootU == rootV)
            return false; // ciclo

        if (rank[rootU] < rank[rootV]) {
            parent[rootU] = rootV;
        } else if (rank[rootU] > rank[rootV]) {
            parent[rootV] = rootU;
        } else {
            parent[rootV] = rootU;
            rank[rootU]++;
        }
        return true;
    }
}

public class KruskalWithTrace {
    static int V = 6;
    static List<Edge> edges = new ArrayList<>();

    static void addEdge(int u, int v, int w) {
        edges.add(new Edge(u, v, w));
    }

    public static void main(String[] args) {
        addEdge(0, 1, 6);
        addEdge(0, 2, 1);
        addEdge(0, 3, 5);
        addEdge(1, 2, 2);
        addEdge(1, 4, 5);
        addEdge(2, 3, 2);
        addEdge(2, 4, 6);
        addEdge(3, 5, 4);
        addEdge(4, 5, 3);

        Collections.sort(edges);

        UnionFind uf = new UnionFind(V);
        List<Edge> mst = new ArrayList<>();
        int totalCost = 0;
        int discardedEdges = 0;

        for (Edge edge : edges) {
            if (uf.union(edge.src, edge.dest)) {
                mst.add(edge);
                totalCost += edge.weight;
                if (mst.size() == V - 1) break;
            } else {
                discardedEdges++;
            }
        }

        System.out.println("Aristas seleccionadas para el MST con Kruskal:");
        for (Edge e : mst) {
            System.out.println(e);
        }

        System.out.println("Costo total del MST: " + totalCost);
        System.out.println("Número de aristas descartadas por formar ciclo: " + discardedEdges);

        // Comparación con resultado esperado (Prim)
        System.out.println("Comparación con Prim:");
        if (totalCost == 13) {
            System.out.println("✅ El MST de Kruskal coincide en costo con el de Prim (13).");
        } else {
            System.out.println("❌ El MST de Kruskal difiere del de Prim.");
        }
    }
}
